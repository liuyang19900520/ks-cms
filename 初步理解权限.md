## 权限相关数据库设计
在了解项目是如何进行权限控制之前，我们先看一下关于权限有哪些表
1. 用户表 sys_user
2. 角色表 sys_role
3. 菜单表 sys_menu 
4. 关系表 sys_relation

抛开数据库设计，当初从功能上理解。我们想象如何控制权限，我们先想象以下几个场景
比如老板登录了账号，他能看到工资管理的菜单，而员工登录之后看不到，这就是权限的控制；比如总务能够删除一个离职员的信息而普通员员工则做不到。
那么实现细颗粒度的控制，我们往往需要一些处理和关联，抽象来看，就是用户、角色、权限以及其关联关系。
根据我们这个项目，我们尝试对照看一下
### 权限信息
在这里用一张sys_menu表来承载。
每个字段的功能自己理解一下，其中有一个字段MENU_FLAG，分别代表这个权限是不是菜单（N不是，Y是）。也就是说有一些权限他不是以菜单形式展现的，
对应的我们刚刚将的例子。老板能看到工资管理的菜单，那么工资管理这条权限的这个字段MENU_FLAG就是N，而总务能删除员工，说明删除员工这条权限的这个字段应该就是N。

### 角色
刚刚我们说的老板和总务，对应到程序中，我们可以成为角色。用sys_role来进行管理。他并没有什么特别

### 角色-权限关系表
回到最初的举例，老板能够看到工资，当然也能够删除员工，甚至他可以删除部门等等。所以老板的有多重权限；
总务也一样，他能删除员工，也能增加员工，有时候会和老板的权限重合。
这就是多对多的关系。这里不展开将对应关系了。就拿这个系统来说，这个关系是sys_relation在负责管理。

### 用户
这也是简单，好理解的内容了。我们实现系统的登录等等的操作，要用自己的用户来操作，不能上来就说我是老板、我是总务，因为公司也有可能有多个总务。

在这张表里有一个注意点：
刚刚我们将角色和权限的关系是多对多的关系，那角色和用户呢。实际上也应该是多对多，但是解决这个问题我们发现这个系统没有造新表，
而是使用ROLE_ID这个字段，出现多重角色的时候，用逗号隔开来处理。

## 使用shiro的配置
参考：https://segmentfault.com/a/1190000013875092
这是一篇将shiro入门和权限介绍的文章，比自己整理的要专业，可以结合着看。

### 基本概念
* subject主体：理解为用户,可能是程序，都要去访问系统的资源，系统需要对subject进行身份认证
* principal身份信息：通常是唯一的，一个主体还有多个身份信息，但是都有一个主身份信息（primary principal）【我们可以选择身份证认证、学生证认证等等都是我们的身份信息】
* credential凭证信息：可以是密码 、证书、指纹。


### securityManager
通过刚才简单的介绍，我们知道主体进行认证和授权都是通过securityManager进行。
``` java
        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
        securityManager.setRealm(this.shiroDbRealm());
        securityManager.setCacheManager(cacheShiroManager);
        securityManager.setRememberMeManager(rememberMeManager);
        securityManager.setSessionManager(sessionManager);
```
* shiroDbRealm是我们自己的认证域，从文档中我们知道，它相当于数据源，通过realm存取认证、授权相关数据。
* rememberMeManager 可以理解记住我的功能，就是让我们下次无需登录就可以进入系统。参考：https://blog.csdn.net/xtiawxf/article/details/52625104
* cacheShiroManager 缓存管理器，主要对session和授权数据进行缓存，比如将授权数据通过cacheManager进行缓存管理，和ehcache整合对缓存数据进行管理。
在我们的项目里缓存处理是通过EhCacheConfig来配置的，具体的项目在ehcache.xml中，具体的参数注释写得比较清楚了，这里就不再赘述了。
* 这里DefaultWebSessionManager 是session管理器，havingValue = "false" 在application.yml中进行了配置，所以我们目前是单机版本。

### 过滤器链
``` java
    @Bean
    public ShiroFilterFactoryBean shiroFilter(DefaultWebSecurityManager securityManager) {
        ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();
        shiroFilter.setSecurityManager(securityManager);
        /**
         * 默认的登陆访问url
         */
        shiroFilter.setLoginUrl("/login");
        /**
         * 登陆成功后跳转的url
         */
        shiroFilter.setSuccessUrl("/");
        /**
         * 没有权限跳转的url
         */
        shiroFilter.setUnauthorizedUrl("/global/error");

        /**
         * 覆盖默认的user拦截器(默认拦截器解决不了ajax请求 session超时的问题,若有更好的办法请及时反馈作者)
         */
        HashMap<String, Filter> myFilters = new HashMap<>();
        myFilters.put("user", new GunsUserFilter());
        shiroFilter.setFilters(myFilters);

        /**
         * 配置shiro拦截器链
         *
         * anon  不需要认证
         * authc 需要认证
         * user  验证通过或RememberMe登录的都可以
         *
         * 当应用开启了rememberMe时,用户下次访问时可以是一个user,但不会是authc,因为authc是需要重新认证的
         *
         * 顺序从上到下,优先级依次降低
         *
         * api开头的接口，走rest api鉴权，不走shiro鉴权
         *
         */
        Map<String, String> hashMap = new LinkedHashMap<>();
        for (String nonePermissionRe : NONE_PERMISSION_RES) {
            hashMap.put(nonePermissionRe, "anon");
        }
        hashMap.put("/**", "user");
        shiroFilter.setFilterChainDefinitionMap(hashMap);
        return shiroFilter;
    }
```
简单整理一下，首先覆盖默认的user拦截器的部分，主要是为了对应ajax请求的内容。GunsUserFilter中做了ajax请求的操作：
``` java
    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {
        HttpServletRequest httpServletRequest = WebUtils.toHttp(request);
        HttpServletResponse httpServletResponse = WebUtils.toHttp(response);

        /**
         * 如果是ajax请求则不进行跳转
         */
        if (httpServletRequest.getHeader("x-requested-with") != null
                && httpServletRequest.getHeader("x-requested-with").equalsIgnoreCase("XMLHttpRequest")) {
            httpServletResponse.setHeader("sessionstatus", "timeout");
            return false;
        } else {

            /**
             * 第一次点击页面
             */
            String referer = httpServletRequest.getHeader("Referer");
            if (referer == null) {
                saveRequestAndRedirectToLogin(request, response);
                return false;
            } else {

                /**
                 * 从别的页面跳转过来的
                 */
                if (ShiroKit.getSession().getAttribute("sessionFlag") == null) {
                    httpServletRequest.setAttribute("tips", "session超时");
                    httpServletRequest.getRequestDispatcher("/login").forward(request, response);
                    return false;
                } else {
                    saveRequestAndRedirectToLogin(request, response);
                    return false;
                }
            }
        }
    }
```
最后设置了不需要shiro鉴权的相关路径，完成了shiroFilter的配置。


## 关注登录功能
首先，登录的请求路径为@RequestMapping(value = "/login", method = RequestMethod.POST),该请求不需要拦截，所以直接会走入ShiroDbRealm中进行验证。
``` java
    /**
     * 登录认证
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authcToken)
            throws AuthenticationException {    
        UserAuthService shiroFactory = UserAuthServiceServiceImpl.me();
        UsernamePasswordToken token = (UsernamePasswordToken) authcToken;
        User user = shiroFactory.user(token.getUsername());
        ShiroUser shiroUser = shiroFactory.shiroUser(user);
        return shiroFactory.info(shiroUser, user, super.getName());
    }
```
由于登录的方法没有权限的认证，所以filter没有拦截，直接进入到了Controller中。
currentUser.login(token)负责进入我们的
在登录认证的方法中，首先我们获得UserAuthServiceServiceImpl的实例。在UserAuthServiceServiceImpl类中，实现了获取用户、创建shiroUser、获得权限、获得角色、info（验证处理）等等。
随后token强转为UsernamePasswordToken，这个token是在controller中实例化的
通过在UserAuthServiceServiceImpl类中的user方法，得到改账户
储存ShiroUser用户，这个ShiroUser作为自定义的验证信息对象，包含了处理登录名称之外更多的信息，比如邮箱、图像、部门、角色、等等
最后返回的验证的结果，调用的是UserAuthServiceServiceImpl中的info方法，如果成功会继续执行
后续内容应该就是记录登录日志，关于日志操作，后续其他的文档中再统一说明。

## 关注初始化功能
刚才我们从登录的controller方法中知道了，记录之日操作之后，会重定向到首页，下面我们就会来看一下首页进行了哪些操作。
首先在gunsUserFilter中，Subject得到Principal信息，如果不为空的时候，就说明是属于登录状态后，可以直接进入到controller中进行操作
在controller中，我们得到了roleList，根据roleList，我们需要得到menuList，
在MenuService中，getMenusByRoleIds这个方法调用最后在MenuMapper.xml中的getMenusByRoleIds方法，其中mapper的sql问如下：
``` sql
SELECT
	m1.MENU_ID AS id,
	m1.ICON AS icon,
	( CASE WHEN ( m2.MENU_ID = 0 OR m2.MENU_ID IS NULL ) THEN 0 ELSE m2.MENU_ID END ) AS parentId,
	m1.NAME AS NAME,
	m1.URL AS url,
	m1.LEVELS AS levels,
	m1.MENU_FLAG AS ismenu,
	m1.SORT AS num 
FROM
	sys_menu m1
	LEFT JOIN sys_menu m2 ON m1.PCODE = m2.
	CODE INNER JOIN ( SELECT MENU_ID FROM sys_menu WHERE MENU_ID IN ( SELECT MENU_ID FROM sys_relation rela WHERE rela.ROLE_ID IN ( 1 ) ) ) m3 ON m1.MENU_ID = m3.MENU_ID 
WHERE
	m1.MENU_FLAG = 'Y' 
ORDER BY
	LEVELS,
	m1.SORT ASC
```
上述ROLE_ID IN ( 1 )是我自己改如的，实际上应该是我们的roleList的列表。
虽然关联了m1,m2,m3三张表。但是我们可以看出来，这就是通过roleId得到的menuId,一次左关联得到parentId，一次内关联获得该roleId对应的menuId。
限制条件MENU_FLAG = 'Y'代表只能获取菜单的内容
之后得到的menus，我们为每一个url加上系统的域名前缀，再返回最后的menus。

然后将得到的menus后，通过menuNode类中的buildTitle方法，来构建title的菜单。这个过程中首先删除非菜单的权限，剩下的内容都是菜单权限，
由于menuNode实现了Comparable接口，所以 Collections.sort(nodes);调用compareTo方法实现排序。这个排序方式先按照level排序，level相等后再根据num排序。
而mergeList方法，我们将返回一个只有第一层的菜单列表，这个逻辑稍微有点麻烦，但是结论很清晰，就是返回一个只有第一层的nodeList




















